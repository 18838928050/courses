# 正则表达式

各位小伙伴大家好，咱们接着前面的课程，继续讲解 GitHub 开源之旅第九季：Linux Bash 入门，现在咱们讲解第五个话题：七年之痒之正则表达式。

接正如你所见到的，Linux 系统中，文本数据起着举足轻重的作用。所以接下来的三个话题，分别是：正则表达式、文本处理和格式化输出，我们将会介绍一些用来操作文本的工具。正则表达式是一个比较神奇，而且比较基础性的技术，我们先来学习这个技术。

正则表达式到底是什么呢？简单来说，正则表达式是一种符号表示法，用来识别文本模式。在某种程度上，它与 shell 通配符比较相似。但正则表达式功能更强大。许多命令行工具和大多数的编程语言都支持正则表达式，来解决文本操作问题。但是，并不是所有系统的正则表达式规则都是一样的，这里面我们先讲一些基本的正则表达式语法，然后再讲一些扩展的正则表达式语法。具体使用时，小伙伴们要视具体情况而定。

## grep

我们将用到的主要程序是我们的老朋友，grep 命令，它会用到正则表达式。实际上，“grep”这个名字来自于短语“global regular expression print”，所以我们能看出 grep 程序和正则表达式有关联。本质上，grep 程序会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。

到目前为止，我们已经使用 grep 程序查找了固定的字符串，就像这样:

    [wangding@LAB ~]$ ls /usr/bin | grep bus

这个命令会列出，位于目录 /usr/bin 中，文件名中包含子字符串“bus”的所有文件。

grep 命令的格式如下：

    grep [options] regex [file...]

这里的 regex 是指一个正则表达式。

常用的 grep 选项列表如 PPT 上所示：

<table class="multi">
<caption class="cap">表20-1: grep 选项</caption>
<tr>
<th class="title">选项</th>
<th class="title">描述</th>
</tr>
<tr>
<td valign="top" width="20%">-i</td>
<td valign="top">忽略大小写。不会区分大小写字符。也可用--ignore-case 来指定。 </td>
</tr>
<tr>
<td valign="top">-v</td>
<td valign="top">不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会不包含匹配项的文本行。也可用--invert-match 来指定。 </td>
</tr>
<tr>
<td valign="top">-c</td>
<td valign="top">打印匹配的数量（或者是不匹配的数目，若指定了-v 选项），而不是文本行本身。也可用--count 选项来指定。 </td></tr>
<tr>
<td valign="top">-l</td>
<td valign="top">打印包含匹配项的文件名，而不是文本行本身，也可用--files-with-matches 选项来指定。</td>
</tr>
<tr>
<td valign="top">-L</td>
<td valign="top">相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用--files-without-match 来指定。</td>
</tr>
<tr>
<td valign="top">-n</td>
<td valign="top">在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number 选项来指定。</td>
</tr>
<tr>
<td valign="top">-h</td>
<td valign="top">应用于多文件搜索，不输出文件名。也可用--no-filename 选项来指定。 </td>
</tr>
</table>

为了更好的探究 grep 程序，让我们创建一些文本文件来搜寻：

    [wangding@LAB ~]$ ls /bin > dirlist-bin.txt
    [wangding@LAB ~]$ ls /usr/bin > dirlist-usr-bin.txt
    [wangding@LAB ~]$ ls /sbin > dirlist-sbin.txt
    [wangding@LAB ~]$ ls /usr/sbin > dirlist-usr-sbin.txt
    [wangding@LAB ~]$ ls dirlist*.txt
    dirlist-bin.txt     dirlist-sbin.txt    dirlist-usr-sbin.txt
    dirlist-usr-bin.txt

我们能够对我们的文件列表执行简单的搜索，像这样：

    [wangding@LAB ~]$ grep bus dirlist*

在这个例子里，grep 程序在所有列出的文件中搜索字符串 bus，然后找到若干个匹配项，都在文件 dirlist-bin.txt 和 dirlist-usr-bin.txt 两个文件中。如果我们只是对包含匹配项的文件感兴趣，而不是对匹配项本身感兴趣的话，我们可以指定 -l 选项：

    [wangding@LAB ~]$ grep -l bus dirlist*

相反地，如果我们想查看不包含匹配项的文件列表，我们可以这样操作：

    [wangding@LAB ~]$ grep -L bus dirlist*

## 元字符和文本

到目前为止，我们还没有发挥 grep 的强大威力呢。因为我们使用的正则表达式，其实是最简单的一种，这个正则表达式“bus”意味着，匹配项所在行至少包含 3 个字符，并且按照字符 “b”, “u”, 和 “s”的顺序出现在匹配行的某处，字符之间没有其它的字符。字符串“bus”中的所有字符都是原义字符，因为它们匹配本身。这其实是一种精确匹配。除了原义字符之外，正则表达式也可以包含元字符，用来指定更复杂的匹配项。掌握了这些元字符，才能充分发挥正则表达式的强大威力。换句话说，正则表达式最强大的是，第二种形式：模糊匹配。只有包含了元字符，我们的正则表达式才能进行模糊匹配，否则只能进行精确匹配。元字符并不多，各有各的用途。掌握正则表达式，其实就是掌握这些元字符分别代表什么，然后在此基础上，碰到实际问题时，灵活运用这些元字符。

    ^ $ . [ ] { } - ? * + ( ) | \

然后其它所有字符都被认为是原义字符，虽然在个别情况下，反斜杠会被用来创建元序列，也允许元字符被转义为原义字符，而不是被解释为元字符。

---

注意：正如我们所见到的，当 shell 执行展开的时候，许多正则表达式元字符，也是对 shell 有特殊含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号引起来至关重要，这样可以阻止 shell 试图展开它们。

---

## 任何字符

我们将要查看的第一个元字符是圆点字符，其被用来匹配任意字符。如果我们在正则表达式中包含它，它将会匹配在此位置的任意一个字符。这里有个例子：

    [wangding@LAB ~]$ grep -h '.bus' dirlist*

我们在文件中查找包含正则表达式“.bus”的文本行。对于搜索结果，有几点需要注意一下。注意没有找到这个 bus 程序。这是因为在我们的正则表达式中包含的圆点字符把所要求的匹配项的长度增加到四个字符，并且字符串“bus”只包含三个字符，所以这个 zip 程序不匹配。另外，如果我们的文件列表中有一些文件的扩展名是.bus，则它们也会成为匹配项，因为文件扩展名中的圆点符号也会被看作是“任意字符”。

## 锚点

在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式只有在文本行的开头或末尾被找到时，才算发生一次匹配。这两个符号大家是不是看着很眼熟，对了在 vim 中插入字符将光标移动到行首的非零字符处，而美元符号，会将光标移到行尾。发现了吗？我们学过的东西，会在很多地方用到，Linux 越学越轻松。

    [wangding@LAB ~]$ grep -h '^bus' dirlist*
    [wangding@LAB ~]$ grep -h 'bus$' dirlist*

这里我们分别在文件列表中搜索行首，行尾以及行首和行尾同时包含字符串“bus”（例如，bus 独占一行）的匹配行。注意正则表达式‘^$’（行首和行尾之间没有字符）会匹配空行。

## 中括号表达式和字符类

除了能够在正则表达式中的给定位置匹配任意字符之外，通过使用中括号表达式，我们也能够从一个指定的字符集合中匹配一个单个的字符。通过中括号表达式，我们能够指定一个字符集合（包含在不加中括号的情况下会被解释为元字符的字符）来被匹配。在这个例子里，使用了一个两个字符的集合：

    [wangding@LAB ~]$ grep -h '^[dg]bus' dirlist*

我们匹配包含字符串“dbus”或者“gbus”的任意行。

一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符是插入字符，其被用来表示否定；第二个是连字符字符，其被用来表示一个字符范围。

## 否定

如果在正则表示式中的第一个字符是一个插入字符，则剩余的字符被看作是不会在给定的字符位置出现的字符集合。通过修改之前的例子，我们试验一下：

    [wangding@LAB ~]$ grep -h '[^dg]bus' dirlist*

通过激活否定操作，我们得到一个文件列表，它们的文件名都包含字符串“bus”，并且“bus”的前一个字符是除了“d”和“g”之外的任意字符。注意文件 bus 没有被发现。一个否定的字符集仍然在给定位置要求一个字符，但是这个字符必须不是否定字符集的成员。

这个插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去它的特殊含义，变成字符集中的一个普通字符。

## 传统的字符区域

如果我们想要构建一个正则表达式，它可以在我们的列表中找到每个以大写字母开头的文件，我们可以这样做：

    [wangding@LAB ~]$ grep -h '^[ABCDEFGHIJKLMNOPQRSTUVWXYZ]' dirlist*

这只是一个在正则表达式中输入26个大写字母的问题。但是输入所有字母非常令人烦恼，所以有另外一种方式：

    [wangding@LAB ~]$ grep -h '^[A-Z]' dirlist*

通过使用一个三个符区域，我们能够缩写 26 个字母。任意字符的区域都能按照这种方式表达，包括多个区域，比如下面这个表达式就匹配了所有以字母和数字开头的文件名：

    [wangding@LAB ~]$ grep -h '^[A-Za-z0-9]' dirlist*

在字符区域中，我们看到这个连字符被特殊对待，所以我们怎样在一个正则表达式中包含一个连字符呢？方法就是使连字符成为表达式中的第一个字符。考虑一下这两个例子：

    [wangding@LAB ~]$ grep -h '[A-Z]' dirlist*

这会匹配包含一个大写字母的文件名。然而：

    [wangding@LAB ~]$ grep -h '[-AZ]' dirlist*

上面的表达式会匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。

## 扩展的正则表达式

我们把正则表达式的实现分成了两大类：基本正则表达式（BRE）和扩展的正则表达式（ERE）。刚才讲的所有正则表达式的元符号都是 BRE，现在咱们介绍 ERE 范畴的元符号。

BRE 和 ERE 之间有什么区别呢？这是关于元字符的问题。BRE 可以辨别以下元字符：

    ^ $ . [ ] *

其它的所有字符被认为是文本字符。ERE 添加了以下元字符（以及与其相关的功能）:

    ( ) { } ? + |

然而（这也是有趣的地方），在 BRE 中，字符“(”，“)”，“{”，和 “}”用反斜杠转义后，被看作是元字符，相反在 ERE 中，在任意元字符之前加上反斜杠会导致其被看作是一个文本字符。在随后的讨论中将会涵盖很多奇异的特性。

因为我们将要讨论的下一个特性是 ERE 的一部分，我们将要使用一个不同的 grep 程序。照惯例，一直由 egrep 程序来执行这项操作，但是 GUN 版本的 grep 程序也支持扩展的正则表达式，当使用了-E 选项之后。

## 替换

我们将要讨论的扩展表达式的第一个特性叫做替换。就像中括号表达式允许从一系列指定的字符之间匹配单个字符那样，可选允许从一系列字符串或者是其它的正则表达式中选择匹配项。首先，让我们试一个普通的字符串匹配：

    [wangding@LAB ~]$ grep -hE 'bus|zip' dirlist*

这里我们看到正则表达式'bus|zip'，这意味着“匹配字符串 bus 或者是字符串 zip”。注意因为这是一个扩展的特性，我们给 grep 命令（虽然我们能以 egrep 程序来代替）添加了-E 选项，并且我们把这个正则表达式用单引号引起来，为的是阻止 shell 把竖杠线元字符解释为一个管道操作符。可选并不局限于两种选择：为了把替换项和其它正则表达式元素结合起来，我们可以使用括号 () 来分离替换。

    [wangding@LAB ~]$ grep -Eh '^(bus|zip)' dirlist*

这个表达式将会在我们的列表中匹配以“bus”，或“zip”开头的文件名。如果我们删除了圆括号，这个表达式的意思：

    [wangding@LAB ~]$ grep -Eh '^bus|zip' dirlist*

会变成匹配任意以“bus”开头，或包含“zip”的文件名。

## 限定符

扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。

### ? - 匹配零个或一个元素

让我们试一下：

    [wangding@LAB ~]$ ls
    [wangding@LAB ~]$ ls | grep -E 'dirlist-[a-z]?bin\.txt'
    [wangding@LAB ~]$ ls | grep -E 'dirlist-.?bin\.txt'
    [wangding@LAB ~]$ ls | grep -E 'dirlist-([a-z][a-z][a-z]-)?bin\.txt'
    [wangding@LAB ~]$ ls | grep -E 'dirlist-(....)?bin\.txt'

这里我们看到这个表达式匹配这个电话号码的两种形式，但是不匹配包含非数字字符的号码。

## \* - 匹配零个或多个元素

像 ? 元字符一样，这个 \* 被用来表示一个可选的字符；然而，又与 ? 不同，匹配的字符可以出现任意多次，不仅是一次。比方说我们想要知道是否一个字符串是一句话；也就是说，字符串开始于一个大写字母，然后包含任意多个大写和小写的字母和空格，最后以句号收尾。为了匹配这个（非常粗略的）语句的定义，我们能够使用一个像这样的正则表达式：

    [wangding@LAB ~]$ ls | grep -E 'dirlist-(.*-)?bin\.txt'

### + - 匹配一个或多个元素

这个 + 元字符的作用与 * 非常相似，除了它要求前面的元素至少出现一次匹配。这个正则表达式只匹配那些由一个或多个字母字符组构成的文本行，字母字符之间由单个空格分开，这个就不在演示了。

### { } - 匹配特定个数的元素

这个 { 和 } 元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：

<table class="multi">
<caption class="cap">表20-3: 指定匹配的数目</caption>
<tr>
<th class="title">限定符</th>
<th class="title">意思</th>
</tr>
<tr>
<td valign="top" width="25%">{n}</td>
<td valign="top">匹配前面的元素，如果它确切地出现了 n 次。</td>
</tr>
<tr>
<td valign="top">{n,m}</td>
<td valign="top">匹配前面的元素，如果它至少出现了 n 次，但是不多于 m 次。</td>
</tr>
<tr>
<td valign="top">{n,}</td>
<td valign="top">匹配前面的元素，如果它出现了 n 次或多于 n 次。</td>
</tr>
<tr>
<td valign="top">{,m}</td>
<td valign="top">匹配前面的元素，如果它出现的次数不多于 m 次。</td>
</tr>
</table>

    [wangding@LAB ~]$ ls | grep -E 'dirlist-([a-z]{3}-)?bin\.txt'
    [wangding@LAB ~]$ ls | grep -E 'dirlist-(.{4))?bin\.txt'

## 让正则表达式工作起来

前面我们已经把正则表达式的语法，基本上都介绍到了。linux 中的很多文本处理命令都支持正则表达式。现在咱们一块看看一些我们已经学过的命令，看看结合正则表达式如何使用。从这里你也会看到 Linux 的学习非常有趣，那就是你学到的东西很多地方都能用到，有一种触类旁通的感觉。

### 通过 grep 命令来验证一个电话簿

在我们先前的例子中，我们查看过单个电话号码，并且检查了它们的格式。一个更现实的情形是检查一个数字列表，所以我们先创建一个列表。我们将念一个神奇的咒语到命令行中。它会很神奇，因为我们还没有涵盖所涉及的大部分命令，但是不要担心。我们将在后面的章节里面讨论那些命令。这就是那个咒语：

    [wangding@LAB ~]$ for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDO
    M:0:3}-${RANDOM:0:4}" >> phonelist.txt; done

这个命令会创建一个包含10个电话号码的名为 phonelist.txt 的文件。每次重复这个命令的时候，另外10个号码会被添加到这个列表中。我们也能够更改命令开头附近的数值10，来生成或多或少的电话号码。如果我们查看这个文件的内容，然而我们会发现一个问题：

    [wangding@LAB ~]$ cat phonelist.txt
    (232) 298-2265
    (624) 381-1078
    (540) 126-1980
    (874) 163-2885
    (286) 254-2860
    (292) 108-518
    (129) 44-1379
    (458) 273-1642
    (686) 299-8268
    (198) 307-2440

一些号码是残缺不全的，但是它们很适合我们的需求，因为我们将使用 grep 命令来验证它们。

一个有用的验证方法是扫描这个文件，查找无效的号码，并把搜索结果显示到屏幕上：

    [wangding@LAB ~]$ grep -Ev '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$'
    phonelist.txt
    (292) 108-518
    (129) 44-1379
    [wangding@LAB ~]$

这里我们使用-v 选项来产生相反的匹配，因此我们将只输出不匹配指定表达式的文本行。这个表达式自身的两端都包含定位点（锚）元字符，是为了确保这个号码的两端没有多余的字符。这个表达式也要求圆括号出现在一个有效的号码中，不同于我们先前电话号码的实例。

### 用 find 查找丑陋的文件名

这个 find 命令支持一个基于正则表达式的测试。

    [wangding@LAB ~]$ find -regex '.*txt'
    [wangding@LAB ~]$ find -regex '.*-bin.txt'

由于要精确地匹配整个路径名，所以我们在表达式的两端使用了.\*，来匹配零个或多个字符。在表达式中间，我们使用了否定的中括号表达式，其包含了我们一系列可接受的路径名字符。

### 在 less 和 vim 中查找文本

less 和 vim 两者享有相同的文本查找方法。按下/按键，然后输入正则表达式，来执行搜索任务。如果我们使用 less 程序来浏览我们的 phonelist.txt 文件：

    [wangding@LAB ~]$ less phonelist.txt

然后查找我们有效的表达式：

    (232) 298-2265
    (624) 381-1078
    (540) 126-1980
    (874) 163-2885
    (286) 254-2860
    (292) 108-518
    (129) 44-1379
    (458) 273-1642
    (686) 299-8268
    (198) 307-2440
    ~
    /^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$

less 将会高亮匹配到的字符串，这样就很容易看到无效的电话号码：

    (232) 298-2265
    (624) 381-1078
    (540) 126-1980
    (874) 163-2885
    (286) 254-2860
    (292) 108-518
    (129) 44-1379
    (458) 273-1642
    (686) 299-8268
    (198) 307-2440
    ~
    (END)

另一方面，vim 支持基本的正则表达式，只是正则表达式的写法略微有些区别：
[需要安装一下 vim-enhanced，否则 vim 命令不认识]

    [wangding@LAB ~]$ vim phonelist.txt

    /([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}

我们看到表达式几乎一样；然而，在扩展表达式中，许多被认为是元字符的字符在基本的表达式中被看作是文本字符。只有用反斜杠把它们转义之后，它们才被看作是元字符。

## 总结归纳

好，本次课程的全部内部到这里就结束了，咱们一块看一下通关任务。请看完视频的小伙伴们完成以下通关任务。
