# 开源项目简介

各位小伙伴大家好，咱们接着前面的课程，继续讲解 Github 开源之旅第六季：how-to-markdown。现在咱们讲解开源项目简介这个话题。

GitHub 是全球最大的开源社区，上面托管的项目可多了去了，我们看到 GitHub 给出的官方数据，截至 2016 年年底，GitHub 上托管的项目数量达到三千多万个。在这么庞大数量的项目面前，我们很多新手一下子就蒙圈了。项目太多了，无从下手，想参与项目不知道自己能做点儿什么。这恐怕是很多新手刚接触开源社区时，都会面临的问题。在这里我们有必要跟小伙伴们介绍一下开源软件或项目的情况，主要是介绍一下开源软件和项目的分类，让小伙伴们有个宏观的把握，来指导自己的项目实践。

## 语言角度

对开源项目最直观、最简单的分类就是编程语言。也就是说，这个项目或者这个软件是用什么编程语言开发的。

【打开 GitHub 网站 workshopper 组织页面】
我们看到每个项目仓库下面都有一个带颜色的圆点，圆点的右侧写着这个项目所使用的语言。当然，可能一个项目会用多种语言混合开发，而这个项目上只显示一个圆点，那当然是项目中使用最多的的编程语言了。我们也看到文档型项目仓库所使用的语言是没有标示的，其实就是 MarkDown 语言。

【进到 learnyounode 仓库页面】
我们看到这个仓库页面下面，有一个彩色的横条，当我们点击这个彩色横条的时候，我们会看到这个项目实际使用的编程语言有三种：HTML、CSS 和 JavaScript，以及这三种语言在项目中所占的比例。当然，HTML 语言用的最多，所以项目列表上只显示 HTML。而且，每种语言的颜色编码是固定的。

了解到这一点之后，在参与开源项目时，我们往往会选择参与自己熟悉的编程语言的项目。

## 规模角度

另一个比较直观和简单的分类方法就是：规模。对于代码规模我们最常用的衡量参数就是代码行数。这个开源软件项目是个几十行、几百行的微型项目，还是个几千行的小项目，还是上万行的中型项目，还是几十万行的大型项目，甚至是上百万行的超大型项目。我们用代码行数来评价项目规模。

对于初学者，我们一般都喜欢从一些规模小的项目下手，这样我们理解起来不太困难，参与这样的项目也不用花太多的时间和精力。这样的项目在 GitHub 上有吗？当然有，而且还不少，就怕我们很多小伙伴看不上眼。

GitHub 没有非常直观和简单的办法让我们来快速评估一个代码仓库的规模。一般可以采用的方法是在 GitHub 网站，在仓库页面中看一个仓库目录中代码文件的数量，如果文件夹以及文件数量比较多，那么这个项目比较大。反之，则比较小。当然这种办法只能看个大概，如果要相对比较精确的衡量项目的代码行数，我们可以把整个项目克隆到本地，然后用代码分析工具来分析项目规模。大家网上搜索一下，能搜到很多代码行数分析工具。其实，还有一种更简单的办法，我们可以直接通过 Bash 命令来分析代码行数。

给大家举个例子。

以 info-theory-lab-c 仓库为例。这个仓库下面放的我之前写的 C 语言的程序，有两个文件夹 capacity 和 entropy。capacity.c 是计算信道容量的程序，entropy.c 是计算信源熵的程序。计算一个代码文件的代码行数：

```bash
wc -l capacity/capacity.c       # 计算 capacity.c 文件的代码行数
cat capacity/capacity.c | less  # 你会发现，代码中有很多空行，也计算在里面了
```

改进一下，去掉空行。

```bash
grep -v ^$ capacity/capacity.c | wc -l   # grep 命令去掉代码文件中的空行
```

可是这个 Bash 命令只能查看一个代码文件的代码行数，如果一个项目有很多代码文件，总不能对每个代码文件都执行一遍上面的命令，得到每个代码文件的行数再去求和，这样就太麻烦了吧。

```bash
find . -name "*.[ch]" | xargs cat | grep -v ^$ | wc -l    # find 命令查找当前目录下面的所有 .c 和 .h 文件，然后计算代码行数
```

## 功能角度

功能角度也是对软件和项目的一种重要分类方法。这个问题不难理解，我们直接给小伙伴们按功能从简单到复杂，举一些常见的开源软件项目的例子好了。

功能最简单的项目仓库，甚至称不上软件。就是各种脚本类的项目，包括：Selenium IDE web 自动化测试脚本的仓库，网站样式的 CSS 脚本仓库，Shell 脚本仓库，vim 或者 git 的配置文件，等。

例如：
搜索一下 Selenium IDE 的自动化脚本的代码仓库。在 wangding/seIDE 仓库里，找 baidu/search.html 代码，找到里面的特征代码，去 GitHub 上搜索一下。（特征代码是下面示例代码的第四行）能找到一大堆这样的仓库和代码来。

```html
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head profile="http://selenium-ide.openqa.org/profiles/test-case">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="selenium.base" href="https://www.baidu.com/" />
<title>baidu search</title>
</head>
```

搜索一下 stylish 的 CSS 脚本，在 wangding/simple-clear-style 仓库里，找 hostedredmine-com.css 代码，找到里面的特征代码，去 GitHub 上搜索一下。（特征代码是下面示例代码的第一行中的 url 地址）能找到一大堆这样的仓库和代码来。

```css
@namespace url(http://www.w3.org/1999/xhtml);

@-moz-document domain("hostedredmine.com") {
#sidebar {
    display: none;
    width: 0%;
}
 
div#content {
    width: 95%;
}
```

Shell 脚本、vim 和 git 的配置文件我就不再举例说明了。

其次，各种插件项目仓库，包括：vim 插件，火狐浏览器插件，等。

例如：
直接在 GitHub 上搜索 vim 关键字，在搜索结果中选择 Vim script 语言，会看到一堆 vim 插件的项目仓库。看一个 vim 插件的仓库吧，VundleVim/Vundle.vim，你会看到还有中文的帮助文档呢！

再次，代码模块项目仓库，包括：nodejs 代码模块，其他语言的代码模块，等。

例如：
```bash
npm list -g        # 列出当前安装的全局模块，找个自己感兴趣的模块，在 npmjs.com 网站上搜索该模块
npm show date-now  # 查看 date-now 模块的信息，其实就是 package.json 里面的信息
```

还有功能不太复杂的，包括：单页面的各种网站应用，等。

例如：
chvin/react-tetris 俄罗斯方块游戏

功能复杂度升个级的各类应用软件，例如：git，vscode，firefox，等。功能再复杂的就是服务类软件了，例如：Apache，ngix，等。终极复杂的就是平台类软件了，例如：Linux 内核等。这些项目的仓库我就不带着大家一个一个去看了，大家应该自己能找的到。

上面由简单到复杂的项目举例，大家可以根据自己目前的能力，从小项目或者适合自己的项目做起，慢慢的随着自己技术的积累，参与到更复杂的项目当中去，这个过程都是一步一步来的，谁也不可能一口吃个胖子。

## 内容角度、工程角度和主客角度

接下来这三种分类方式，不太复杂，我们就不再详细展开并举例说明了，就一块简单说一下。

内容角度，小伙伴们可能知道，软件等于程序加文档。内容角度意味着我们参与开源项目，是贡献代码还是贡献文档。当然，贡献文档相对来说技术难度会低一些。

工程角度，小伙伴们可能知道，软件工程中经常提到过程模型，也就是说一个软件从无到有都需要经历哪些过程。一般来说，包括：需求分析、设计、编码、测试和上线运营。工程角度就意味着，我们参与项目时，是在哪个阶段参与的，或者说参与的是哪一类工作。例如，我们是参与软件的代码编写，还是软件的架构设计，还是对软件进行的测试，还是参与软件的需求分析，等等。当然，不同的工作内容对我们的技术能力要求都是不一样的。

最后，主客角度。这个也不难理解，如果我们参与他人的项目，则他人是主，我们是客。而如果他人参与我们的开源项目，则我们是主，他人是客。主客角度看似简单，但是这里面是有大文章的。主和客的地位是不平等的，这一点我们一定要注意，否则，很容易在开源项目中碰壁。自己满腔热情的贡献了代码，却遭到了拒绝，结果对开源社区心灰意冷。一旦出现这种情况，往往是我们没有搞清楚主客关系。如果我们参与他人的项目，作为客人，我们能够参与的内容往往会受限，如果提交项目的 bug 或者 bug 的 Pull Request，这些都会非常受欢迎，这样的 Pull Request 会非常容易合并。因为，我们帮助主人完善了他的软件。反之，如果我们提交的 Pull Request 是对软件代码进行重构或者对软件增加了新功能，这些贡献往往会遭到主人的拒绝。因为，主人一般会自己来决定项目的功能需求或发展方向。这一点大家一定要注意。其实这是人之常情，我们换位思考一下，就能理解了。如果我们是某开源软件的创始人，他人要修改我们软件的功能或者对软件代码进行重构，我们也会非常慎重的，不会轻易让别人这样大刀阔斧的鼓捣我们的代码。

说到这里，可能有的小伙伴要怀疑了，原来开源社区也是江湖啊。一点儿都不自由，一点儿都不平等，一点儿都不好玩。如果我们发现软件代码需要重构，或者软件功能需要提升，我们有能力做到，却得不到软件原作者的认可，这不就没得玩了吗？其实，不是这样的，这里有变通的办法，这儿这种玩法，在开源社区中已经非常流行和成熟了。办法是什么呢？就是另起炉灶。

举个例子
【NeoVim】

好，这样咱们这一节就讲到这里，接下来咱们一块看一下本讲的通关任务。
