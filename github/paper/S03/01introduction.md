# 课程简介

【幻灯片：封面】  
各位小伙伴大家好，Github 开源之旅第三季：Git 进阶课程终于和大家见面了。

## 前置课程

【幻灯片：前置课程】  
学习本门课程之前，建议大家先学习两门课程：Github 开源之旅第一季：启程和 Github 开源之旅第二季：MarkDown，并且需要认真完成这两门课程的通关任务。

【幻灯片：系列课程路线】  
本门课程作为系列课程的第三门课程，在课程路线中的位置如图所示。跟着课程一路学下来的小伙伴，想必现在已经在 Github 上注册账户了，**【鼠标在第一季课程上晃动】**已经在 Github 上创建了几个仓库了。而且已经会用 MarkDown 编写文档了**【鼠标在第二季课程上晃动】**，有可能已经在 Github 上创建了一两个文档型的项目仓库了。咱们课程的设计就是让大家尽快上手，尽快使用，在边学边用的过程中，找到学习的乐趣，发现学习的动力以及发现自身的不足。

一路跟过来的小伙伴，现在应该碰到了不少 Git 方面的问题了，在这里，大家千万不要有挫折感，不要认为工具难用，实际上是咱们学的东西太少了，不够用，这就是书到用时方恨少。咱们这个 Git 进阶课程需要对 Git 工具进一步深入讲解一番。相信大家学完了这门课程，心中的很多困惑都会消除。你会感觉到，自己的功力又提升了一大截，距离我们独自在开源江湖上闯荡的那一天又接近了很多。

## Git 简介

【幻灯片：Git 简介】  
先简单介绍一下 Git 简介，之前在 Github 开源之旅第一季：启程的课程中，咱们介绍了 Github 的简介，Git 咱们只介绍了一些常用的命令，为了快速上手，很多必要的背景知识都没有交代。这此课咱们把这些坑都逐一填上。

Git 是开源的分布式的版本管理系统。关于这一点，咱们后面再具体说明。

### Git 历史

很多人都知道，Linus 在 1991 年打造了开源的 Linux 操作系统，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。

Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？

事实是，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！

你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。

不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。

安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。

Linus 本可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：

Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。

Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。

历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。

### 谁在用 Git

【幻灯片：谁在用 Git】
这里有一个很简短的清单，告诉大家都有那些著名的软件在使用 Git 做版本控制，当然这只是庞大冰山的一个非常小的一角。因为，我们看了 2016 年 Github 的年度报告，就知道截止 2016 年 Github 上托管的开源项目的数量就达到了三千四百万个。当然，Github 是世界上最大的开源社区，除了 Github 还有很多其他的项目托管平台也在使用 Git 做版本控制，比如，国内的开源中国，他的代码托管平台叫码云。代码的码，马云的云。这样算起来，用 Git 做代码托管的项目就太多太多了。而现在的版本控制系统主流的就是两个 svn 和 git，所以学习并使用 Git 确实是一个非常正确的选择。

### Git 的优势

【幻灯片：Git 的优势】
Git 的优势，咱们就不再一一为大家解释了，大家自己看一眼就好了，总归我们要坚定信心，Git 确实是非常值得学习和掌握的一项重要技术。

### 三种版本控制系统

**本地版本控制系统**

许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。

为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。
本地版本控制图解

![](images/local.png)
【幻灯片：本地版本控制】

其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
集中化的版本控制系统

接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。

**集中化的版本控制**

![](images/centralized.png)
【幻灯片：集中化的版本控制】

这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。

事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。
分布式版本控制系统

于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。

**分布式版本控制**

![](images/distributed.png)
【幻灯片：分布式版本控制】

更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。

### 存储方式

Git 基础

那么，简单地说，Git 究竟是怎样的一个系统呢？ 请注意接下来的内容非常重要，若你理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。 在开始学习 Git 的时候，请努力分清你对其它版本管理系统的已有认识，如 Subversion 和 Perforce 等；这么做能帮助你使用工具时避免发生混淆。 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。
直接记录快照，而非差异比较

Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。
存储每个文件与初始版本的差异。

![](images/deltas.png)
Figure 4. 存储每个文件与初始版本的差异.

Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。
Git 存储项目随时间改变的快照。

![](images/snapshots.png)
Figure 5. 存储项目随时间改变的快照.

这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 稍后我们在Git 分支讨论 Git 分支管理时，将探究这种方式对待数据所能获得的益处。
近乎所有操作都是本地执行

在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让你感到速度之神赐给了 Git 超凡的能量。 因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。

举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。

这也意味着你离线或者没有 VPN 时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。 如你回家后 VPN 客户端不正常，你仍能工作。 使用其它系统，做到如此是不可能或很费力的。 比如，用 Perforce，你没有连接服务器时几乎不能做什么事；用 Subversion 和 CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。 这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。

三种状态

好，请注意。 如果你希望后面的学习更顺利，记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。

由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。
工作目录、暂存区域以及 Git 仓库。

![](images/lifecycle.png)

Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。

工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。

暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。

基本的 Git 工作流程如下：

    在工作目录中修改文件。

    暂存文件，将文件的快照放入暂存区域。

    提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。

如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 在Git 基础一章，你会进一步了解这些状态的细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。


记录每次更新到仓库

现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。 接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。

请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。

编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：
Git 下文件生命周期图。
Figure 8. 文件的状态变化周期


## 课程安排

因为 Git 工具的学习路线比较长，用一个专业的术语叫学习路线比较陡峭。其实，把概念搞清楚之后，学习难度并不大，主要还是一方面多练习，另一方面，真正在自己的工作中用起来。哪怕真的没有可以托管的代码，也要在上面没事儿，放一点 DemoCode 或者写写文档之类的。这是一个很重要的学习经验、学习方法。所以，课程视频在制作的时候，尽可能主题单一，这样方便大家跳跃的学习和检索，另外就是，每个主题后面都安排有练习和作业，希望大家不要光看视频，像看电视连续剧式的学习课程，那样学习的效果不好，一定要把每个课程视频后面的通关任务完成，一定要多练。

我把课程规划为一个系列课程，这样一方面可以降低大家的学习难度，另一方面，可以让课程规模不至于过于庞大。通过这个系列课程，最终，一定让大家能够有能力参与到开源社区的开源项目中。目前，暂时规划了四块内容，当然，随着课程的开展后续的内容可能会调整。希望大家不要介意。


