# 课程简介

【幻灯片：封面】  
各位小伙伴大家好，Github 开源之旅第三季：Git 进阶课程终于和大家见面了。

## 前置课程

【幻灯片：前置课程】  
学习本门课程之前，建议大家先学习两门课程：Github 开源之旅第一季：启程和 Github 开源之旅第二季：MarkDown，并且需要认真完成这两门课程的通关任务。

【幻灯片：系列课程路线】  
本门课程作为系列课程的第三门课程，在课程路线中的位置如图所示。跟着课程一路学下来的小伙伴，想必现在已经在 Github 上注册账户了，**【鼠标在第一季课程上晃动】**已经在 Github 上创建了几个仓库了。而且已经会用 MarkDown 编写文档了**【鼠标在第二季课程上晃动】**，有可能已经在 Github 上创建了一两个文档型的项目仓库了。咱们课程的设计就是让大家尽快上手，尽快使用，在边学边用的过程中，找到学习的乐趣，发现学习的动力以及发现自身的不足。

一路跟过来的小伙伴，现在应该碰到了不少 Git 方面的问题了，在这里，大家千万不要有挫折感，不要认为工具难用，实际上是咱们学的东西太少了，不够用，这就是书到用时方恨少。咱们这个 Git 进阶课程需要对 Git 工具进一步深入讲解。相信大家学完这门课程后，心中的很多困惑都会消除。你会感觉到，自己的功力又提升了一大截，距离我们独自在开源江湖上闯荡的那一天又接近了很多。

## 课程安排

先看一下本次课程的大纲，**【切换到课程大纲思维导图】**课程的主体是六块内容，内容都是由浅入深，比较难的内容都放到了后面。课程的重点是分支操作。**【幻灯片：课程大纲】**每个主题下面设置了课后的通关任务，大家一定要多加练习。**【幻灯片：课程资料页面】**课程资料页面在 Github 王顶的个人主页，下面的 courses 仓库的 Github 目录下。**【打开课程资料页面】**打开课程资料页面给大家看一下。

每门课程，我们都花了很多心血在里面。每门课程除了课程视频以外，还有配套的：课程大纲，幻灯片，课程资料页面和通关任务。这是咱们课程的特色，从教与学的规律出发，让小伙伴们真正能学到东西。你想一想这样制作一门课程比只录制课程视频是不是要多花更多的时间和精力啊，基本上在 51CTO 上像这样设计和制作的课程应该仅此一家。所以，用现在时髦的话来说就是，且学且珍惜。

## Git 简介

【幻灯片：Git 简介】  
好下面，咱们开始介绍课程的正式内容。首先简单介绍一下 Git，之前在 Github 开源之旅第一季：启程的课程中，咱们介绍了 Github，Git 咱们只介绍了一些常用的命令，为了快速上手，很多必要的背景知识都没有交代。这次课咱们把这些坑都逐一填上。

Git 是**开源**的**分布式**的版本管理系统。关于**分布式**这一点，咱们后面再具体说明。

### Git 历史

很多人都知道，Linus 在 1991 年打造了开源的 Linux 操作系统，从此，Linux 系统不断发展，已经成为最大的服务器操作系统软件了。

Linus 虽然创造了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？

事实上，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！

你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS 和 SVN 好用，但那是付费的，和 Linux 的开源精神不符。

不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。

安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（其实这么干的并不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。

Linus 本可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：

Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之后，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。

Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。

历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。

### 谁在用 Git

【幻灯片：谁在用 Git】  
这里有一个很简短的清单，告诉大家都有哪些著名的软件在使用 Git 做版本控制，当然这只是庞大冰山的一个非常小的一角。因为，我们看了 2016 年 Github 的年度报告，就知道截止 2016 年 Github 上托管的开源项目的数量就达到了三千四百万个。当然，Github 是世界上最大的开源社区，除了 Github 还有很多其他的项目托管平台也在使用 Git 做版本控制，比如，开源中国，他的代码托管平台叫码云。代码的码，白云的云。这样算起来，用 Git 做代码托管的项目就太多太多了。所以学会使用 Git 确实是一个非常正确而明智的选择。

### Git 的优势

【幻灯片：Git 的优势】  
Git 的优势，咱们就不再一一为大家解释了，大家自己看一眼就好了，总归我们要坚定信心，Git 确实是非常值得学习和掌握的一项重要技术。关于优势中的两条：分布式和节省磁盘空间，咱们下面来详细解释一下。

### 三种版本控制系统

关于版本控制系统的现实机制，大致分成三个大类，这三个大类也是 VCS 进化的一个方向，分别是：本地版本管理系统、集中版本管理系统和分布版本管理系统。这里有三幅图，大致描述了三种版本管理系统的差异。咱们分别来看一下，首先是本地版本管理系统。

**本地版本控制系统**

【幻灯片：本地版本控制】  
在没有版本控制系统之前，许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易出错。 有时候会混淆所在的工作目录，一不小心会改错文件或者意外覆盖文件。

为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。

![](images/local.png)

其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。

**集中化的版本控制系统**

【幻灯片：集中化的版本控制】  
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。

![](images/centralized.png)

这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。

凡事都有两面性。 这么做最明显的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。

**分布式版本控制系统**

【幻灯片：分布式版本控制】  
于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。

![](images/distributed.png)

更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。

这里我们还有一个略微复杂一些的图来说明同样的问题。下面，给大家**演示**一下分布式的版本系统。以 wangding/test 仓库为例，在这个 win10 电脑上 clone 一份，在 win7 的虚拟机上克隆一份。每一份，都和服务器上的内容完全相同。可以看一下，文件和文件夹，以及提交的历史信息。

### 存储方式

以上就是咱们说的 Git 的优点之一的分布式，下面咱们聊一下 Git 的另一个优点，节省磁盘存储空间。这就不得不提一下 Git 的存储方式了。当然，我们这里只是简单的讲一下。

Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。

**存储每个文件与初始版本的差异**

![](images/deltas.png)

Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。

Git 存储项目随时间改变的快照。**直接记录快照，而非差异比较**。

![](images/snapshots.png)
Figure 5. 存储项目随时间改变的快照.

这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 这样做的好处就是 Git 在分支操作上会非常高效和便捷，开销非常小。本次课程的后面，咱们会重点讲解 Git 的分支操作，换句话说，如果学习 Git 没有掌握分支操作，那么咱们 Git 的使用水平还停留在幼儿园的水平，当然，如果自己一个人玩是没有问题的，但是团队协作就不行了。

看了这两个图，你可能会有疑问。不对啊，Git 如果存储文件快照，不应该比存储差异更节省存储空间啊。其实这个图里没有把节省存储空间的问题都说清楚，节省存储空间基本上是靠两个手段来完成的，一，Git 存储的文件快照，都是用 gzip 格式压缩的；二，Git 也用一个称为打包文件的方式来存储，打包文件其实就是存储文件的变更和差异。

### 三个区域

好，请注意。 如果你希望 Git 的学习更顺利，请记住下面这两幅图：三个区域和四种状态。这三个区域和四种状态一定要记住，甚至要把图印在脑子里。三个区域分别是：工作目录、暂存区域以及 Git 仓库。

![](images/areas.png)

- Git 仓库是位于仓库目录下一个 .git 的隐藏文件夹。 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。  
- 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。  
- 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。  

基本的 Git 工作流程如下：

- 在工作目录中修改文件。
- 暂存文件，将文件的快照放入暂存区域。
- 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。

### 四种状态

如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。如果新建一个或若干文件，就是未被跟踪状态。

请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。

编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：

![](images/lifecycle.png)
Figure 8. 文件的状态变化周期

三个区域和四种状态，这两幅图是等价的。大家一定要能融会贯通，从三个区域能看出四种状态，从四种状态能看出三个区域来。
